#
# I/O functions, those generally involving stdout, stderr, stdin
#

# most of these functions will check the length of var $quiet and will not
# output anything (or less at least) if $quiet is not empty, allows scripts
# to do stuff like if [ "$arg" == "-q" ]; then quiet=1;fi
function puts {
  # echos '[*] ' and arguments with the -e and -n flags (to stdout)
  # only print something if quiet is empty
  [ -z "$quiet" ] && echo -en "[*] $@"
}
export -f puts

function eqo {
  # echos the arguments with no frills, but only if not quiet
  # only print something if quiet is empty
  [ -z "$quiet" ] && echo "$@"
}
export -f eqo

function warn {
  # warnings, i.e. non-fatal errors to stdout
  # echos '[-] ' and arguments with the -e and -n flags (to stdout)
  # only print something if quiet is empty or not empty but less than a value?
  # local quiet_threshold
  # [ $quiet -lt $quiet_threshold ] && echo -en "[-] $@"
  [ -z "$quiet" ] && echo -en "[-] $@"
}
export -f warn

function die {
  # fatal or nearly-fatal errors, if you give a second argument, it is used as an exit code
  # echos '[!] ' and first argument with the -e and -n flags and redirect to stderr
  # if a second argument is given, this function will exit with that argument as the code
  # NOTE:  $quiet does not affect the output
  echo -en "[!] $1" >&2
  if [ $2 ]; then exit $2;fi
}

# allows you to easily debug variables as varname:varvalue
function investigate {
  local output_prefix='' # could be something like [*]
  local output_sep=": " # could be ", " ": " etc
  for varname in $@; do
    echo -n "${output_prefix}${varname}${output_sep}"
    v='echo $'
    v="${v}$(echo $varname)"
    eval $v
  done
}
export -f investigate
